# Automated array sorting
Algorithms taken from articles on Habré and Wikipedia are presented in the "sorting algorithms" folder.

---
Realizable algorithms.

- [x] [Bubble](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC)
- [x] [Shaker](http://algolab.valemak.com/cocktail)
- [x] [Insertion](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0%D0%BC%D0%B8)
- [x] [Stooge](https://ru.wikipedia.org/wiki/Stooge_sort)
- [x] [Pancake](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%B8%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [x] [Shell](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%A8%D0%B5%D0%BB%D0%BB%D0%B0)
- [x] [Merge](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)
- [x] [Selection](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%BE%D0%BC)
- [x] [Quick](https://neerc.ifmo.ru/wiki/index.php?title=%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [x] [Gnome](http://algolab.valemak.com/gnome)
- [x] [Tree](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0,_%D0%BD%D0%B0%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)
- [x] [Comb](http://algolab.valemak.com/comb)
- [x] [BasicCounting](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82%D0%BE%D0%BC)
- [x] [CombinedBubble](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC)
- [x] [Heapify](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BA%D1%83%D1%87%D0%B5%D0%B9)
- [x] [Cocktail](http://algolab.valemak.com/cocktail)
- [x] [OddEven](http://algolab.valemak.com/odd-even)
- [x] [Tim](https://neerc.ifmo.ru/wiki/index.php?title=Timsort)
- [x] [Counting](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D0%B5%D1%82%D0%BE%D0%BC)
- [x] [Radix](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A6%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [x] [Bucket](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9A%D0%B0%D1%80%D0%BC%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [x] [BinaryInsertion](https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)
- [x] [Bogo](https://ru.wikipedia.org/wiki/Bogosort)
- [x] [Cycle](https://en.wikipedia.org/wiki/Cycle_sort)
- [x] [Exchange](https://mathbits.com/MathBits/Java/arrays/Exchange.htm)
- [x] [Heap](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [x] [MSDRadix](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [ ] [PSRS](https://neerc.ifmo.ru/wiki/index.php?title=PSRS-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [ ] [Multithreaded](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)
- [ ] [Han's](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%A5%D1%8D%D0%BD%D0%B0_(%D0%B8%D0%BB%D0%B8_%D0%A5%D0%B0%D0%BD%D0%B0%3F))
- [ ] [Patience](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A2%D0%B5%D1%80%D0%BF%D0%B5%D0%BB%D0%B8%D0%B2%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)
- [ ] [Smooth](https://neerc.ifmo.ru/wiki/index.php?title=Smoothsort)

---

Below is a table with the main sorting features.

| Name           | The best time      | Average                         | Worse                   | Memory  |
| -------------- |:------------------------:| -------------------------:| -----------------------:| -------:|
| Bubble         | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Shaker         | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Insertion      | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Stooge         | O(n^(log 3) / log 1.5))  | O(n^(log 3) / log 1.5))   | O(n^(log 3) / log 1.5)) | O(n)    |
| Pancake        | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Shell          | O(n (log^2 n))           | Depends on step selection | O(n^2)                  | O(n)    |
| Merge          | O(n logn)                | O(n logn)                 | O(n logn)               | O(n)    |
| Selection      | O(n^2)                   | O(n^2)                    | O(n^2)                  | O(n)    |
| Quick          | O(n logn)                | O(n logn)                 | O(n^2)                  | O(logn) |
| Gnome          | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Tree           | O(n)                     | O(n logn)                 | O(n logn)               | O(n)    |
| Comb           | O(n)                     | O((n^2) / 2^p)            | O(n^2)                  | O(n)    |
| BasicCounting  | O(n)                     | O(n+k)                    | O(n+k)                  | O(n+k)  |
| CombinedBubble | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Heapify        | O(n logn)                | O(n logn)                 | O(n logn)               | O(n)    |
| Cocktail       | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| OddEven        | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |

| Tim            | O(n^2)                   | O(n^2)                    | O(n^2)                  | O(n)    |
| Counting       | O(n logn)                | O(n logn)                 | O(n^2)                  | O(logn) |
| Radix          | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Bucket         | O(n)                     | O(n logn)                 | O(n logn)               | O(n)    |
| BinaryInsertion| O(n)                     | O((n^2) / 2^p)            | O(n^2)                  | O(n)    |
| Bogo           | O(n)                     | O(n+k)                    | O(n+k)                  | O(n+k)  |
| Cycle          | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| Exchange       | O(n logn)                | O(n logn)                 | O(n logn)               | O(n)    |
| Heap           | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |
| MSDRadix       | O(n)                     | O(n^2)                    | O(n^2)                  | O(n)    |


Brief description of each algorithm taken from different sites.

# Bubble 

The algorithm consists of repeated passes through the sorted array. At each iteration, neighboring elements are sequentially compared, and if the order in the pair is incorrect, then the elements are swapped. For each pass through the array, at least one element falls into place, so it is necessary to make no more than n−1 passes, where n is the size of the array, to sort the array.

Below is the pseudocode for bubble sort, which takes the array a[0..n−1] as input.
```
function bubbleSort(a):
  for i = 0 to n - 2
    for j = 0 to n - 2
      if a[j] > a[j + 1]
        swap(a[j], a[j + 1])
```
#### 10 -> 2000 Synthetic
![Bubble](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Bubble.PNG)
#### 10 -> 2000 Real
![Bubble](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Bubble.PNG)

# Shaker

A multiple run through the array is performed, neighboring elements are compared and, if necessary, swapped. When the end of the array is reached, the direction is reversed. Thus, large and small array elements are pushed in turn to the end and the beginning of the structure, respectively. Cocktail sort is also called two-way sorting by simple exchanges. There is a similar modification for selection sorting.

#### Cocktail sort in Python
```
def cocktail(data): 
    up = range(len(data) - 1)       
    while True:
        for indices in (up, reversed(up)):
            swapped = False
            for i in indices:
                if data[i] > data[i+1]:  
                    data[i], data[i+1] =  data[i+1], data[i]
                    swapped = True
            if not swapped:
                return data
```

#### 10 -> 2000 Synthetic
![Shaker](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Shaker.PNG)
#### 10 -> 10000 Real
![Shaker](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Shaker.PNG)

# Insertion

The problem is this: there is a part of the array that is already sorted, and you want to insert the remaining elements of the array into the sorted part, while maintaining the order. To do this, at each step of the algorithm, we select one of the input data elements and insert it at the desired position in the already sorted part of the array, until the entire input data set is sorted. The method of selecting the next element from the input array is arbitrary, but usually (and in order to obtain a stable sorting algorithm), elements are inserted in the order of their appearance in the input array.

Since only neighboring elements can change places during the algorithm operation, each exchange reduces the number of inversions by one. Therefore, the number of exchanges is equal to the number of inversions in the original array, regardless of the sorting implementation. The maximum number of inversions is contained in an array whose elements are sorted in non-increasing order. The number of inversions in such an array is n(n−1)2.

The algorithm runs in O(n+k), where k is the number of exchanges of elements of the input array, equal to the number of inversions. On average and in the worst case - for O(n2). The minimum estimates occur in the case of an already ordered initial sequence of elements, the worst - when they are arranged in reverse order.

```
function insertionSort(a):
  for i = 1 to n - 1
    j = i - 1
    while j ⩾ 0 and a[j] > a[j + 1] 
      swap(a[j], a[j + 1])
      j--
```

#### 10 -> 2000 Synthetic
![Insertion](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Insertion.PNG)
#### 10 -> 10000 Real
![Insertion](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Insertion.PNG)

# Stooge

Stooge sort (Stack sort[1], Wandering sort[2]) is a recursive sorting algorithm with time complexity {\displaystyle O(n^{\log _{1{,}5}{3)))\approx O( n^{2.71})}O(n^{{\log _{{1{,}5}}{3}}})\approx O(n^{{2.71}}). The running time of the algorithm is thus extremely long compared to efficient sorting algorithms such as Merge Sort.

The algorithm for sorting a list of elements is as follows:

If the value of the element at the end of the list is less than the value of the element at the beginning, then swap them.
If there are 3 or more elements in the current list subset, then:
Recursively call Stooge sort on the first 2/3 of the list
Recursively call Stooge sort on the last 2/3 of the list
Recursively call Stooge sort on the first 2/3 of the list again
Else: return

```
 algorithm stoogesort(array L, i = 0, j = length(L)-1)
     if L[j] < L[i] then
         L[i] ↔ L[j]
     if j - i > 1 then
         t = (j - i + 1)/3
         stoogesort(L, i  , j-t)
         stoogesort(L, i+t, j  )
         stoogesort(L, i  , j-t)
     return L
```

#### 10 -> 1000 Synthetic
![Stooge](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Stooge.PNG)
#### 10 -> 1000 Real
![Stooge](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Stooge.PNG)

# Pancake

Pancake sorting (from the English pancake sorting) is a sorting algorithm. The only operation allowed in the algorithm is to reverse the elements of the sequence up to some index. Unlike traditional algorithms that minimize the number of comparisons, pancake sort requires as few flips as possible. The process can be visualized as a stack of pancakes, which is shuffled by taking several pancakes from above and turning them over.

#### 10 -> 2000 Synthetic
![Pancake](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Pancake.PNG)
#### 10 -> 2000 Real
![Pancake](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Pancake.PNG)

# Shell

Shellsort is a sorting algorithm that is an improved version of insertion sort.

Each pass in the algorithm is characterized by an offset hi, such that elements that are lagging behind each other by hi positions are sorted. Shell suggested using ht=N/2, ht−1=ht/2, … , h0=1. Other offsets are also possible, but h0=1 always.

Start.
Step 0. i=t.
Step 1. Let's split the array into lists of elements that are separated by hi. Such lists will be hi.
Step 2. Sort the elements of each list by insertion sort.
Step 3. Combine the lists back into an array. Decrease i. If i is non-negative, go back to step 1
End.

#### 10 -> 10000 Synthetic
![Shell](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Shell.PNG)
#### 10 -> 10000 Real
![Shell](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Shell.PNG)

# Merge

The algorithm uses the “divide and conquer” principle: the problem is divided into smaller subproblems, which are solved separately, after which their solutions are combined to obtain a solution to the original problem. Specifically, the merge sort procedure can be described as follows:

If the array under consideration has one element, then it is already sorted - the algorithm terminates.
Otherwise, the array is split into two parts, which are sorted recursively.
After sorting the two parts of the array, the merge procedure is applied to them, which, using the two sorted parts, gets the original sorted array.

```
function merge(a : int[n]; left, mid, right : int):
    it1 = 0
    it2 = 0
    result : int[right - left]
  
    while left + it1 < mid and mid + it2 < right
        if a[left + it1] < a[mid + it2]
            result[it1 + it2] = a[left + it1]
            it1 += 1
        else
            result[it1 + it2] = a[mid + it2]
            it2 += 1
  
    while left + it1 < mid
        result[it1 + it2] = a[left + it1]
        it1 += 1
  
    while mid + it2 < right
        result[it1 + it2] = a[mid + it2]
        it2 += 1
  
    for i = 0 to it1 + it2
        a[left + i] = result[i]
```

#### 10 -> 10000 Synthetic
![Merge](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Merge.PNG)
#### 10 -> 10000 Real
![Merge](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Merge.PNG)

# Selection

At each i-th step of the algorithm, we find the i-th minimum element and swap it with the i-th element in the array. This will result in an array sorted in non-descending order.

```
 function selectionSort(T[n] a):
   for i = 0 to n - 2
     for j = i + 1 to n - 1
       if a[i] > a[j]
         swap(a[i], a[j])
```

#### 10 -> 2000 Synthetic
![Selection](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Selection.PNG)
#### 10 -> 2000 Real
![Selection](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Selection.PNG)

# Quick

Quick sort is one of the most famous and widely used sorting algorithms. The average running time is O(nlogn), which is the asymptotically optimal running time for a comparison-based algorithm. Although the running time of the algorithm for an array of n elements can be Θ(n2) in the worst case, in practice this algorithm is one of the fastest.

```
  void quicksort(a: T[n], int l, int r)
     if l < r
        int q = partition(a, l, r)
        quicksort(a, l, q)
        quicksort(a, q + 1, r)
```

#### 10 -> 2000 Synthetic
![Quick](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Quick.PNG)
#### 10 -> 10000 Real
![Quick](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Quick.PNG)

# Gnome 

"Gnome sorting is based on a technique used by a common Dutch garden gnome (Dutch. tuinkabouter). This is the method by which a garden gnome sorts a line of flower pots. It essentially looks at the next and previous garden pots: if they are in the correct order, it steps one pot forward, otherwise it swaps them and steps back one pot. Boundary conditions: if there is no previous pot, it steps forward; if there is no next pot, it is finished."

Dick Grun

Dwarf sorting is an optimized stupid sorting. In stupid sorting, when an unsorted pair of neighbors is found, an exchange occurs and a return to the beginning of the array. Dwarven sorting is just one step back.

Also, the algorithm is interesting in that only one cycle is used, which is very rare for sorting algorithms.

There is an optimized version for gnome sorting.

#### Cocktail sort in Python
```
def gnome(data):
    i, size = 1, len(data)
    while i < size:
        if data[i - 1] <= data[i]:
            i += 1
        else:
            data[i - 1], data[i] = data[i], data[i - 1] 
            if i > 1:
                i -= 1
    return data
```

#### 10 -> 2000 Synthetic
![Gnome](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Gnome.PNG)
#### 10 -> 10000 Real
![Gnome](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Gnome.PNG)

# Tree 

Binary search tree (BST) is a data structure for working with ordered sets.
A binary search tree has the following property: if x is a binary tree node with key k, then all nodes in the left subtree must have keys less than k, and in the right subtree

```
func insert(x : Node, z : Node):            // x — корень поддерева, z — вставляемый элемент
   while x != null
     if z.key > x.key
        if x.right != null
           x = x.right
        else
           z.parent = x
           x.right = z
           break
     else if z.key < x.key
        if x.left != null
           x = x.left
        else
           z.parent = x
           x.left = z
           break
```

#### 10 -> 2000 Synthetic
![Tree](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Tree.PNG)
#### 10 -> 2000 Real
![Tree](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Tree.PNG)

# Comb

Repeated passes are made through the array, in which pairs of elements are compared. If they are not sorted relative to each other, then an exchange is made. As a result, large elements migrate to the end of the array, and small ones migrate to the beginning.

In bubble sort, each time it passes through the array, adjacent elements are compared. Here, elements are compared, between which there is some fixed distance. With each subsequent passage, the distance decreases until it reaches the minimum value.

The decreasing distance between compared elements is calculated using a special value called the reduction factor. The length of the array is divided by this factor, and this is the gap between the indices. After each pass, the distance is divided by the reduction factor and thus a new value is obtained. In the end, it narrows down to the minimum value - one, and the array is simply re-sorted with the usual "bubble".

#### Cocktail sort in Python
```
def comb(data):
    gap = len(data)
    swaps = True
    while gap > 1 or swaps:
        gap = max(1, int(gap / 1.25))  # minimum gap is 1
        swaps = False
        for i in range(len(data) - gap):
            j = i + gap
            if data[i] > data[j]:
                data[i], data[j] = data[j], data[i]
                swaps = True
    return data
```

#### 10 -> 10000 Synthetic
![Comb](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Comb.PNG)
#### 10 -> 10000 Real
![Comb](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Comb.PNG)

# BasicCounting

Counting sort[2] is a sorting algorithm that uses the range of numbers of the sorted array (list) to count matching elements. The use of counting sort is useful only when the sorted numbers have (or can be mapped to) a range of possible values ​​that is small enough compared to the set to be sorted, for example, a million natural numbers less than 1000.

Suppose the input array consists of {\displaystyle n}n integers ranging from {\displaystyle 0}{\displaystyle 0} to {\displaystyle k-1}k-1, where {\displaystyle k\in \mathbb { N} }k \in \mathbb N. Further, the algorithm will be generalized for an arbitrary integer range. There are several modifications of counting sort, below are three linear and one quadratic, which uses a different approach, but has the same name.

```
SimpleCountingSort:
    for i = 0 to k - 1
        C[i] = 0;
    for i = 0 to n - 1
        C[A[i]] = C[A[i]] + 1;
    b = 0;
    for j = 0 to k - 1
        for i = 0 to C[j] - 1
            A[b] = j;
            b = b + 1;
```

#### 10 -> 100000 Synthetic
![BasicCounting](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/BasicCounting.PNG)
#### 10 -> 100000 Real
![BasicCounting](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/BasicCounting.PNG)

# CombinedBubble 

Sort by simple exchanges, bubble sort is a simple sorting algorithm. To understand and implement this algorithm is the simplest, but it is effective only for small arrays. Complexity of the algorithm: {\displaystyle O}O{\displaystyle (n^{2})}(n^{2}).

The algorithm is considered educational and is practically not used outside the educational literature; instead, more efficient sorting algorithms are used in practice. At the same time, the exchange sort method underlies some of the more advanced algorithms, such as shaker sort, heap sort, and quick sort.

```
 FOR J=0 TO N-1 STEP 1
   F=0
   MIN=J
   FOR I=J TO N-1-J STEP 1 
     IF Y[I]>Y[I+1] THEN SWAP Y[I],Y[I+1]:F=1
     IF Y[I]<Y[MIN] THEN MIN=I
   NEXT I
   IF F=0 THEN EXIT FOR
   IF MIN<>J THEN SWAP Y[J],Y[MIN]
 NEXT J
```

#### 10 -> 2000 Synthetic
![CombinedBubble](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/CombinedBubble.PNG)
#### 10 -> 2000 Real
![CombinedBubble](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/CombinedBubble.PNG)

# Heapify

Heap sort, heap sort (eng. Heapsort) is a sorting algorithm that uses a binary heap data structure. This is an unstable sorting algorithm with O(nlogn) running time, where n is the number of elements to sort, and using O(1) additional memory.

```
 fun heapSort(A : list <T>):
   buildHeap(A)
   heapSize = A.size
   for i = 0 to n - 1
     swap(A[0], A[n - 1 - i])
     heapSize--
     siftDown(A, 0, heapSize)
```

#### 10 -> 10000 Synthetic
![Heapify](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Heapify.PNG)
#### 10 -> 10000 Real
![Heapify](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Heapify.PNG)

# Cocktail

A multiple run through the array is performed, neighboring elements are compared and, if necessary, swapped. When the end of the array is reached, the direction is reversed. Thus, large and small array elements are pushed in turn to the end and the beginning of the structure, respectively. Cocktail sort is also called two-way sorting by simple exchanges. There is a similar modification for selection sorting.

#### Cocktail sort in Python
```
def cocktail(data): 
    up = range(len(data) - 1)       
    while True:
        for indices in (up, reversed(up)):
            swapped = False
            for i in indices:
                if data[i] > data[i+1]:  
                    data[i], data[i+1] =  data[i+1], data[i]
                    swapped = True
            if not swapped:
                return data
```

#### 10 -> 2000 Synthetic
![Cocktail](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/Cocktail.PNG)
#### 10 -> 10000 Real
![Cocktail](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/Cocktail.PNG)

# OddEven 

A multiple run through the array is performed, neighboring elements are compared and, if necessary, swapped. Unlike bubble sort, the array step is two, not one.

First, elements with odd indices are compared/exchanged with elements with even indices (1st with 2nd, 3rd with 4th, 5th with 6th, etc.). Then elements with even indices are compared/exchanged with neighboring elements with odd indices (2nd with 3rd, 4th with 5th, 6th with 7th, etc.). Then again the odd ones are compared with the even ones, then again the even ones with the odd ones, and so on. The process ends if there were no exchanges as a result of two runs, which means the array is ordered.

#### Cocktail sort in Python
```
def odd_even(data):
    n = len(data)
    isSorted = 0
    while isSorted == 0:
        isSorted = 1
        for i in range(1, n - 1, 2):
            if data[i] > data[i + 1]:
                data[i], data[i + 1] = data[i + 1], data[i]
                isSorted = 0
                  
        for i in range(0, n - 1, 2):
            if data[i] > data[i + 1]:
                data[i], data[i + 1] = data[i + 1], data[i]
                isSorted = 0
    return data
```

#### 10 -> 2000 Synthetic
![OddEven](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/OddEven.PNG)
#### 10 -> 2000 Real
![OddEven](https://github.com/Mika-dot/Array-sorting/blob/main/complexity%20in%20graphics%20real/OddEven.PNG)


---
Why you need to use custom sorting algorithms. Below is a graph of the speed of the "BasicCounting" and "Array.Sort" algorithms for standard c# sorting.
+ Graph in red "Array.Sort".
+ Graph in black "BasicCounting".

From this we can conclude that the custom algorithm is faster than the standard one.

![comparison](https://github.com/Mika-dot/Automated-array-sorting/blob/main/complexity%20in%20graphics/comparison.PNG)
